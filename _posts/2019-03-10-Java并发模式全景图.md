---
layout: post
title:  "Java并发编程全景图!"
date:   2019-03-10 22:44:11 +0100
---
并发操作可以抽象出三个核心问题，**分工**，**同步**，**互斥**。

---  
```
1. 分工就是有效的将一个任务拆分成许多更小的子任务。
2. 当任务被拆分成子任务分配给线程执行时，不难想到，许多子任务之间是存在依赖关系的，那么线程之间任务的同步就成了关键性问题。例如线程A完成了，那么线程A就要通知到依赖A的B线程，我已经完成了，你可以执行了。
3. 并发程序中，，线程访问的共享变量是无法确定正确性的，无法确定的根本原因则是原子性，有序性，可见性这三个问题。而解决线程安全问题的核心方案就是**互斥**，所谓**互斥**，指的是同一时刻，只能有一个线程访问共享变量。
```
![Java并发全景图]({{ site.url }}/assets/并发全景.png)

---
![Java并发全景思维导图]({{ site.url }}/assets/并发全景思维导图.png)

---

**总结**
- 将任务拆分成更小的子任务执行，Java采用的是线程模型（还有更多的进程，携程模型），拆分之后自然伴随着同步问题。
- 子任务在执行时，不然理解会存在着依赖关系，那么自然衍生出同步问题，关于如何同步，自然而然想到的就是锁了，但是如果只靠锁的话，无疑性能是会收到影响，那么新的闭锁，屏障，队列等就产生了。
- 上锁之后一样会遇到死锁等问题。
- 如果一遇到并发问题，都上锁也就完事儿了，但是追求性能是人类程序员的天性，那么不上锁能否保证线程安全性呢？那么伴随而来的就是CAS算法，无锁数据结构等无锁并发的思想。
- 如果以上所有工作都交给程序员去做的话，那么开发的效率真的会降到极低，于是，依据数据访问正确性的三条原则，原子性，有序性，可见性，Java再次针对这三条规则抽象出了一系列内存访问规则，称之为内存模型！