---
layout: post
title:  "虚拟机类加载机制!"
date:   2019-04-08 20:15:23 +0100
---
虚拟机把描述类的数据从 Class 文件**加载**到内存，并对数据进行**校验**，**转换**，**解析**和**初始化**，最终形成可以被JVM直接使用的Java类型，这就是虚拟机的类加载机制。   

###类的生命周期###
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载这七个阶段。
>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载顺序必须按照这个顺序按部就班的开始，而解析阶段则不一定，它有可能在初始化阶段之后才开始。**注意这里写的是按部就班的开始，而不是按部就班的执行，完成。强调这一点只是因为这些阶段通常都是互相交叉混合式的进行的，通常都会在一个阶段的执行过程中调用，激活另一个阶段。**   

##1.加载##
加载是类加载中的第一个阶段，，在这个阶段中，虚拟机需要完成一下三件事情：
- 通过一个类的全限定名来获取该类的二进制字节流。
- 讲这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。    

**虚拟机规范的这几件事情其实并不具体，所以也就有了比较大的操作空间**。例如第一条，通过一个类的全限定名来获取定义此类的二进制字节流。从哪里获取？如何获取？这些都没有明文规定，所以就诞生了许多方式，**虚拟机团队在加载阶段搭建了一个非常广阔，开放的舞台**，例如：
- 从ZIP包中读取，也就是日后的JAR、WAR格式的基础。
- 从网络中获取。（Applet）
- 运行时动态生成，最著名的就是动态代理。
- 由其他文件生成，最典型的就是JSP应用。    

第一阶段获取到该类的二进制字节流之后，就会按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构，然后在内存中实例化一个java.lang.Class类的对象（并没有明确规定是在堆中，对于HotSpot虚拟机而言，Class对象比较特殊，虽然是对象，但是却存放在方法区中）    

##2.验证##
验证的目的是为了确保Class文件的字节流中包含的信息符合当前的虚拟机要求，不会危害虚拟机的安全。    
Java语言本身算是相对安全的语言，使用存粹的Java代码，无法做到诸如数组边界以外的数据，将一个对象转型为它并未实现的类型，跳转到不存在的代码行之类的，如果这样做了，编译器将拒绝编译。但是前面说了，加载阶段的Class文件字节流可以不以Java源代码编译产生，所以虚拟如果缺少验证输入的字节流，对其完全信任，很可能导致系统崩溃。     
验证阶段是非常复杂的，接下来将其大致分成四个阶段的检验动作，**文件格式验证，元数据验证，字节码验证，符号引用验证。**    
1.文件格式验证     
这一阶段主要是验证字节流是否符合Class文件格式的规范，这阶段的验证是基于二进制字节流进行的，主要目的是保证输入的字节流能正确的解析并存储于方法区之内。只有通过了这个阶段的验证，字节流才会进入方法区内存储。所以后面的验证都是基于方法区内的数据结构进行验证，不再直接操作字节流。   
2.元数据验证    
这一阶段是对字节码描述的信息进行语义分析，也就是对类的元数据信息进行语义校验，保证不存在不符合java语言规范的元数据信息。例如这个类是否拥有父类（理论上除了Object类之外，所有类都应当有父类）。如果这个类不是抽象类，是否实现了父类或接口中定义的要求实现的方法等。    
3.字节码验证    
这个阶段是整个验证中最复杂的一个阶段，**主要目的是通过数据流和控制流分析，确认程序语义是合法的、符合逻辑的**。在元数据阶段完成校验后，这个阶段将对类的方法体进行校验分析。**保证被校验类的方法在运行时不会做出有害虚拟机安全的事件**。如果一个类的方法体没有通过字节码验证，那么它肯定是有问题的，但是即使一个类的方法体通过了字节码验证，也不能说明它就是安全的。   
4.符号引用验证    
**这个阶段的验证发生在虚拟机将符号引用转换成直接引用的时候，这个验证动作将发生在第三阶段-解析阶段中发生**。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验以下内容：     
- 符号引用中通过字符串描述的全限定名能否找到对象的类
- 在指定的类中是否存在符合描述的方法与字段
- 符号引用中的类、字段、方法等的访问性（是否可被当前类访问）   
>对于虚拟机的类加载机制来说，验证阶段是一个非常重要，但不是一定必要的过程，如果所运行的全部代码都已经被反复使用和验证过，那么也可以考虑使用 -Xverify:none参数来关闭大部分的类验证措施，缩短类加载的时间。    

##3.准备##
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用内存都将在方法区中分配。**这时候进行内存分配的变量仅仅只是类变量（被static修饰的变量）,而不包括实例变量，实例变量会在对象实例化时随着对象一起分配在java堆中。而且这里说的初始值指的是数据类型的零值，例如int类型的的初始值就为0**，，假如类变量被定义为final，那么它将会被直接定义为所指定的值。

---

######未完待续######