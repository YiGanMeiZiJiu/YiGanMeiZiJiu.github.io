---
layout: post
title:  "如何用一把锁保护多个资源之synchronized篇"
date:   2019-03-14 21:40:23 +0100
---
Java并发编程中，对于没有关联关系的资源，例如银行账户Account的余额balance与密码password，大可以申请两把锁，分别保护。但是相对于有关联关系的资源，例如A向B转账100元，那么A账户就会减少100元，B账户同理增加100元，那么这两个账户就是有关联关系的。那么这种情况的解决方法呢？我们先将问题代码化，在一步步解析。
---
1. Accout账户实体类，提供未加锁的转账方法，毋庸置疑，存在并发问题
```
public class Account {
    //账户id
    private long id;
    //余额
    private int balance;

    // 基础封装转账方法（未加锁）
    // target目标账户，amt转出金额
    void transferBasic(Account target, int amt) {
        if (this.balance > amt) {
            this.balance -= amt;
            target.balance += amt;
        }
    }
}
```

2. 既然存在未加锁的转账方法存在并发问题，那么首先想到的便是对转账方法加上synchronized关键字修饰，也就是如下代码：
```
    //转账 （对象级别的锁，会有并发问题）
    synchronized void transfer(Account target, int amt) {
        transferBasic(target, amt);
    }
```
>那么此举到底管不管用呢？显而易见，是不好使的，不然就不需要这篇博客了！！问题就出在synchronized关键字上，synchronized关键字修饰实例方法时，锁住的是当前的this对象，this这把锁可以保护自己的余额，但是却保护不了target的余额。举个例子，A给B转账100，B给C转账100，A,B,C的初始余额都是200。那么我们希望得到的结果是A余额100，B余额200，C余额300。但是很遗憾，结果并不会。假设线程1执行A给B转账，线程2执行B给C转账，此时线程1拿到的锁对象是A.this,而线程2拿到的锁对象是B.this。所以很遗憾，他们拿到的锁对象是不一样的，他们并不互斥，可以同时进入锁住的代码临界区，如果线程1先于线程2执行，那么线程1修改的B余额为300的结果则会被线程2修改的B余额为100覆盖。如果线程1后于线程2执行，那么同理，线程2对B的余额修改结果会被覆盖，B的最终结果会是300，就是不可能是200。

3. 那么既然方法前加synchronized关键字不是锁住同一个对象，那么我们只要锁住同一个对象不就行了吗？
```
    //转账（class级别的锁，不存在并发问题）
    void transfer(Account target, int amt) {
        synchronized(Account.class) {
            transferBasic(target, amt);
        }
    }
```
>此时我们方法中锁住的对象是Account.class，这个对象总是不变的吧，那么我们的代码不存在并发问题了吧！很好，恭喜你答对了，并发问题是不存在了，但是这段代码虽然没有问题了，可是很遗憾，它还是没有实用价值。因为全中国大概有几亿用户都有银行卡网上转账吧，转账方法被你这样一锁，所有的转账操作都变成了串行，只要有一个用户在转账，那么其他用户的转账操作都得老实的等着，因为唯一的锁被拿走了。很明显，这并不适用。

4. 既然串行方法不行，那么我们分别锁住转账的两个账户不就行了吗？那样转账操作也不是串行的了。试一试！
```
    //优化转账操作
    void transfer(Account target, int amt) {
        synchronized(this) {
            synchronized(target) {
                transferBasic(target, mat);
            }
        }
    }
```
>这一下分开锁住两个账户，锁住之后才进行转账操作总可以了吧，而且转账操作也不是并行的。但是非常遗憾，这个方法的结果，仍然是no，哈哈哈！原因就是因为极有可能死锁！举个例子吧，当线程1执行A向B转账，线程2执行B向A转账。此时线程1拿到了A.this的锁，而线程2恰好就拿到了B.this的锁，此时线程1会等待，企图拿到B.this的锁，而线程2呢，也会等待想拿到A.this的锁，那么就完蛋，谁也不肯放手，谁也没办法继续执行下去，形成死锁。

---
下面介绍一下死锁吧！！毕竟发生了，知己知彼，才能解决嘛！  
死锁想要发生的话，必须要同时满足以下几种条件！
- **互斥，也就是共享资源只能被一个线程占用或锁定。**
- **占有且等待，线程1获取了共享资源A，在等待共享资源B时，不会释放A。**
- **不可抢占，其他线程不能强行抢占线程1获取的A资源。**
- **循环等待，线程1在等待线程2占有的共享资源，线程2在等待线程1占有的共享资源。**
当且仅当这四个条件都满足时，死锁才会发生，换句话说，我们只要破坏了其中一种条件，那么死锁也就被我们解开了，至于上面转账的方法死锁如何破解，我们专门放到下一篇博客里，详解一下死锁的破解方法！！！
