---
layout: post
title:  "GC总结"
date:   2022-04-10 16:40:57 +0100
---
# GC总结
#### 1.Java常见的垃圾回收器有哪些
串行回收 Serial GC、并行回收 ParNew GC、并行回收升级版 Parallel GC、并发回收 CMS GC、分块并发回收 G1 GC

#### 2.这些GC分别是怎么回收的，都有什么特点，什么情况下适合什么GC？
##### 2.1 串行GC -XX:+UseSerialGC
串行GC代表着在GC回收时，只有一个单线程执行着垃圾回收，年轻代采用标记复制算法，老年代采用标记整理。并且在GC过程中往往伴随着STW，造成业务线程的停顿，即使你的cpu是多核可以并发执行多个线程，仍然会导致只有一个GC线程在执行回收造成cpu资源的浪费。所以串行GC几乎不适用于多核cpu的机器。同时注意，一个单线程GC回收时会占用cpu，如果GC无法回收，会一直占用cpu资源，暂停业务，造成类似死机的情况，其实有可能是一直在Full GC，但回收不出有效的资源。
单核且内存资源较小的机器比较适合Serial GC
##### 2.2 并行GC -XX:+UseParNewGC -XX:+UseParallelGC -XX:+UseParallelOldGC
并行GC与串行GC采用的回收算法是一致的，唯一不同的是，并行GC在回收资源时，采用的是多个线程一起并行回收，所以效率会比串行GC高，同时他也是会STW造成业务停顿的。主要有并发线程数，GC最大停顿时间等配置需要注意。其中ParNew与串行的唯一区别就是一个单线程执行，一个多线程执行。
##### 2.3 ParNew与Parallel与ParallelOld三者的差异与区别
首先Parallel作为ParNew的升级版，升级了一个专注于吞吐量的特性。Parallel是专注于吞吐量的GC，他有两个参数，一个设置吞吐量，一个设置GC最大停顿时间，它更关注于可以调节设置程序的吞吐量。
吞吐量=业务运行时间/(业务运行时间+GC停顿时间)
可以看出吞吐量直接与GC停顿时间这个参数挂钩，GC停顿时间越长，业务运行时间越短。所以我们可以通过调节GC最大停顿时间参数来间接控制吞吐量。但是也不是停顿时间设置的越短，吞吐量越高，只是停顿时间越短，GC会发生的越频繁（因为单次回收的时间段，效果也会差，所以会容易再次发生GC）这其中设置需要自己去取平衡。
Parallel年轻代采用Parallel Scavenge并行回收，老年代采用的则是PSMarkSweep（Serial Old）串行标记整理回收。
Parallel Scavenge允许较长时间的STW去换取最大吞吐量。（因为单次STW时间越长，回收效果越好，程序整体的吞吐量是最大的）
对于Parallel来说：
- 当整个年轻代剩余内存（碎片）无法放下下一个对象时，会直接把这个对象分配去往老年代，而不会Young GC
- 当剩余的总内存大于对象的内存，但Eden区无法直接放下对象（碎片），会触发一次Young GC
- 在执行Young GC后，晋升老年代的平均大小比老年代当前剩余空间大，会触发一次Full GC
- Full GC = Young GC + Old GC
其次对于Parallel与Parallel Old来说，区别在于对于老年代的回收算法上，Parallel对老年代采用的是串行回收，而Parallel Old对老年代同样采用的并行回收。
部分多核机器且内存不是特别大，且对延迟的要求不是特别高的机器适用于并行GC

##### 2.4 并发GC -XX:+UseCMSGC
CMS主要特点区别与并行GC的是，同样作为多线程回收，CMS支持与业务线程并发执行，尽力的减小停顿时间（部分步骤还是需要STW的），来实现程序更小的延迟。CMS主要分6个步骤，只有在其中的初次标记与最终标记是需要STW的，其他四个步骤均支持与业务线程并发执行。相比于并行GC，CMS拥有更小的延迟，但是算法复杂度明显提高，并且GC回收效率不如并行（因为不够专注），且CMS对老年代的回收不做内存整理，采用的是标记，空间列表法，可能会导致内存碎片。
对于部分多核机器且内存不是非常大，且对延迟有要求的机器适用于CMS GC

##### 2.5 G1 GC -XX:+UseG1GC
G1 GC几乎可以算是从CMS脱胎来的，与CMS有差异的是，G1将堆内存拆分成2048个小块，G1的全程叫Garbage first，他每次回收会采样回收的情况，优先回收垃圾较多的小块，而且可以设置单次GC停顿时间，G1内部会动态计算本次GC回收那些部分，以此来达成尽量满足最大停顿时间参数以保证系统延迟。