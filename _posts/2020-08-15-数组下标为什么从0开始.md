---
layout: post
title:  "数组下标为什么从0开始？"
date:   2020-08-15 20:43:57 +0100
---
1. **为什么数组的下标要从0开始而不是从1开始呢？**
- 先从数组的定义开始说起，数组就是线性的用一块连续的内存地址，来存储一列相同数据类型的数据结构。  
- int[] temp = new int[4];
- 计算机会给每一个内存单元分配地址，然后通过地址来访问内存中的数据，假定java数组temp的起始地址为default_address(10000)，int类型存储占data_type_size(4)个字节，那么temp数组的寻址公式就是：
- address[i] = default_address + i * data_type_size;
- 但是如果数组的下标从1开始，那么寻址公式就变成了：
- address[i] = default_address + (i - 1) * data_type_size;
- 可以看得出来，如果下标从1开始的话，计算机会在每一次的数组随机访问时，多执行一次减法运算，可能在日常的业务运算中不明显，但是在语言的最底层开发中，性能的优化需要做到极致。也可能是Java顺延C语言的习惯，下标从0开始。

2. **数组如何实现随机访问？**
- 就是通过👆的公式，在申请数组的时候确定首地址，然后数组是一块线性的连续内存地址，通过下标可以推算出想要访问的内存地址，达到随机访问的目的。
- 所以这也造成了数组在删除和插入的时候性能不高，因为想要保持线性表的连续性，往数组头插入新元素，或者删除头元素，都会导致整个数组的移动。
- 数组插入新元素的复杂度，如果在末尾插入新元素，不需要移动，最好复杂度O(1)。但如果在数组头插入新元素，那所有元素依次往后移动，所以最坏复杂度O(n)。因为在每个位置插入元素的概率都是相等的，所以平均时间复杂度是：(1+2+3+4+...+n)/n = O(n);
- 数组的查询时间复杂度相对较优，数组是适合查找操作，但是切记不是O(1)。即使是排好序的数组，利用二分查找时间复杂度也是O(logn)；O(1)只是数组的根据下标随机访问时间复杂度。

3. **容器与数组的对比优劣？**
- 首先Java的容器无法存储基本类型,只能存放Integer，Long等包装类型。虽然Java支持自动拆箱跟装箱，但是不可避免还是会在性能方面造成一定影响。
- Java的容器优势在于，封装了许多细节，例如数组在插入删除时需要搬运数据等，当然最重要的还是自动扩容，数组在创建时必须指定大小，list则不同，它可以动态扩容，每次自动扩容成为上次的1.5倍大小。不过因为扩容涉及到内存申请和数据搬移，是比较损耗性能的，所以当我们能事先知道需要多大存储空间时，最好创建时提前指定。
- 总结，如果事先知道需要空间大小，并且对数据的操作十分简单，用不到ArrayList的大部分方法。那我们也可以使用数组。相比于日常的开发，完全可以使用ArrayList，省时省力，毕竟相对那么一丢丢性能，ArrayList大部分的方法还是很友好的。但是如果你是开发一些很底层的东西，性能的优化需要做到极致，那么还是考虑一下数组。