---
layout: post
title:  "幻读和间隙锁"
date:   2020-12-01 20:43:57 +0100
---
🍊 幻读是什么？幻读专指新插入的行，读到原本存在行的更新结果不算。因为当前读的作用就是能读到所有已经提交记录的最新值。
1. **幻读产生的前提条件**
- InnoDB引擎
- 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在“当前读”下才会出现。
- 幻读仅专指“新插入的行”。
2. **幻读有什么问题？**
- 首先是语义上的，会造成一个事务中先产生的锁，无法锁住后加入的满足条件的行。而实际上，这个锁的语义被破坏了。
- 其次，是数据一致性的问题。在一个事务中，先对符合条件的目标行做变更，而在事务提交前有新的符合目标条件的行加入。这样通过binlog恢复的数据是会将所有符合条件的目标行都进行变更的。
3. **幻读产生的原因**
- 行锁只能锁住行，即使把所有的记录都加上锁，还是阻止不了新插入的记录，这也是为什么“幻读”会被单独拿出来解决的原因。
4. **如何解决幻读**
- 产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。因此，为了解决幻读问题，InnoDB 只好引入新的锁，也就是间隙锁 (Gap Lock)。
5. **间隙锁**
- 间隙锁，锁的就是两个值之间的空隙
- 间隙锁加锁，就是在一行扫描的过程中，给行两边的空隙，也加上了间隙锁。
- 数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。
- 跟行锁有冲突关系的是“另外一个行锁”，但是间隙锁不一样，跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。
- 间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。
6. **间隙锁带来的问题**
间隙锁和 next-key lock 的引入，帮我们解决了幻读的问题，但同时也带来了一些问题。例如任意锁住一行，如果这一行不存在的话就插入，如果存在这一行就更新它的数据。这个逻辑一旦有并发，就会碰到死锁。死锁的具体原因就是因为每一次的先查，会加上间隙锁，在并发的情况下，可能会导致两个select for update语句因为两个间隙锁冲突导致死锁问题。     
间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。