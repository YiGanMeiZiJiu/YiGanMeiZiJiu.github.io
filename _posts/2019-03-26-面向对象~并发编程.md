---
layout: post
title:  "面向对象~并发编程"
date:   2019-03-26 20:43:57 +0100
---
如何用面向对象思想写好并发程序？关于这个问题，本身面向对象是Java的标志思想，而并发编程跟它也是没有一点关系，分属两个领域的东西。但是他们在Java中出现了一定的契合，好在，融合的效果还是不错的。**在Java语言层面，面向对象思想能让并发编程变的更简单。**    

总结来说，利用面向对象思想进行并发编程可以总结成3点，**1.共享变量封装**，**2.识别共享变量间的约束条件**，**3.制定兵法访问策略**     

1.封装共享变量      
面向对象思想有一个重要的特性就是封装，也就是将属性和实现细节封装在对象内部，然后对外提供公共方法来访问这些私有属性。而利用面向对象思想编写并发程序的思路就是，**将共享变量封装起来，对外提供有并发策略的公共方法来间接访问这个共享变量。**
>例如下面的代码，value作为共享变量，我们将其封装，对外提供synchronized修饰的公共方法，进行value的操作。     

```
public class Count {
    // 共享变量value
    private Long value;

    synchronized Long getValue() {
        return value;
    }

    synchronized void setValue(Long temp) {
        this.value = temp;
    }
}
```
      
2.识别共享变量间的约束条件     
关于识别共享变量间的约束条件这一点，非常容易忽视，但是它却相当的重要。因为，这些条件决定了我们的并发策略。   
>例如，我们举一个库存的例子，库存不能太高，也不能太低。假设存在两个变量，一个库存上限，一个库存下限。结合第一点封装概念，我们写下如下代码。     

```
public class SafeVM {
    //原子类，保证线程安全
    private final AtomicLong high = new AtomicLong(0);
    private final AtomicLong low = new AtomicLong(0);

    //设置库存上限
    void setHigh(Long temp) {
        if (temp < low.get()) {
            // 上限不能小于下限，抛出异常
            return;
        }
        high.set(temp);
    }

    //设置库存下限
    void setLow(Long temp) {
        if (temp > high.get()) {
            //下限不能大于上限
            return;
        }
        low.set(temp);
    }

    //省略其他业务代码
}
```   
>乍一看，**我们的变量用原子类保证并发安全，代码没有问题，但是此时，就是没有注意约束条件出了问题。**举个例子，此时的上下限分别为（2，10）；两个线程，A线程执行将上限设置为5，B线程将下限设置为7.他们同时执行，A在设置上限为5时，B尚未修改下限为7，此时判断条件5 > 2,于是A就将上限修改成了5，同理，B修改下限的时候，A尚未将上限修改成5，此时判断条件10 > 7,于是B将下限修改成了7，于是最后改成了上限5，下限7。这就是不注意约束条件造成的问题！！！     

3.制定并发访问策略    
制定并发访问策略是一件很复杂的事情，但是简单的从方案上来说，也就是三件事：     
- 避免共享：避免共享的技术主要是利用与线程本地存储以及为每个任务分配独立的线程。
- 不变模式：这个在Java领域应用的比较少。
- 管程及其他同步工具：Java领域并发万能的解决方案，管程。当然还有Java并发包提供的锁，并发容器等工具。