---
layout: post
title:  "volatile关键字详解!"
date:   2019-03-05 21:53:32 +0100
---
关键字volatile是jvm提供的几乎可以说是最轻量级的同步机制了，但是大部分人都没有正确的理解它，遇上多线程并发同步问题时，一律使用synchronized来处理，大部分情况下可能会造成资源的无谓浪费。我们还是有必要花一些时间去弄清楚volatile的语义到底是什么。当一个变量被定义为volatile之后，那么该变量将获得两种特性，第一种就是可见性，第二种就是禁止指令重排序。下面就针对这两种特性展开讨论。

####1.可见性

- 可见性指的是当一个变量A被声明为volatile后，**一个线程修改了A的值后，那个修改后的值立刻对其他线程都是可知的。**而我们前面介绍过，在java内存模型的定义中，普通变量的修改均是在各线程的工作内存中进行，而后同步到主内存中完成修改的，所以普通变量的修改是不具备可见性的。

- **也就是说声明为volatile的变量在各线程中是保持一致的。**但是这并不能说明volatile变量就是绝对线程安全的，我们大致可以理解成volatile变量在各线程的工作内存中的是一致的，但是由于java运算并非原子操作，导致volatile变量的运算在并发下还是有可能会出问题。下面有一段代码演示一个例子：   

  ```java
  public class VolatileTest {
      private static volatile int result = 0;
      private static final count = 20;
      
      public static void increase() {
          result++;
      }
      
      public static void main(String[] args) {
          Thread[] threads = new Thread[count];
          for(int i = 0; i < count; i++) {
              threads[i] = new Thread(new Runnable() {
                  @override
                  public void run() {
                      for (int i = 0; i < 10000; i++) {
                          increase();
                      }
                  }
              });
              threads[i].start();
          }
          
          while (Thread.activeCount() > 1)
              Thread.yield();
          System.out.println(result);
      }
  }
  ```

 *以上代码是创建了20个线程，每个线程都将声明为volatile的int变量result自增10000次，依据volatile变量的可见性特性，预测的代码结果应该是200000；但是运行结果却并不是如此，这说明它并不是绝对的线程安全，那么问题出在了哪里呢？问题就出在了*

```java
result++;
```

*这一句代码上，由于java运算并不是原子操作，它的加一操作拆解成字节码指令时，是由好几步构成的。当线程A取到result的值放到操作栈顶时，此时volatile的可见性保证了取到的值是正确的，但是执行add操作时，有可能线程B已经完成了对result变量的自增操作，但此时线程A已经无法感知，仍然用着前面取到的过期值完成了又一次的自增并将其同步回了主内存中。*

* 但是这也不能说明volatile关键字就没有了作用，在某些情况下，volatile的可见性就能够发挥效用，例如：
  - [ ] ***运算结果不依赖当前变量值，或者确保只有单一线程修改变量的值。***
  - [ ] ***变量不需要与其他的状态变量共同参与不变约束***      

#### 2.禁止指令重排序

* 从硬件结构上说，指令重排序是指cpu在能正确处理指令依赖情况并且能保证得出正确的执行结果的情况下，采用了将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。
* 普通的变量仅会保证在方法的执行过程中所有依赖赋值结果的地方都能取到正确的值，而不保证变量赋值操作的顺序与代码中的实际顺序一致，这也就是Java内存模型中的“线程内表现为串行的语义”。
* 由volatile修饰的变量，在赋值后，**会多出一个内存屏障，指令重排序时，不能将后面的指令越过到内存屏障之前，这就是volatile禁止指令重排序的语义所在。**

### 总结

***明确了volatile的语义之后，相比于其他的同步工具，例如synchronized，lock等，即使现在的虚拟机对于锁方面的消除和优化已经十分强大，并且volatile变量在本地代码中执行写操作时需要插入许多的内存屏障指令来保证cpu不会乱序执行（volatile变量读操作的性能消耗几乎与普通变量一致）。不过即便如此，大多数场景下，volatile的总开销仍然低于锁，所以我们在选择volatile和锁中选择的依据就是，volatile是否能满足当前场景。***

---

###附：

> Java内存模型就是围绕着在并发过程中处理原子性，有序性，可见性3个特征来建立的。借着讲过volatile，我们来稍微展开介绍一下那些操作满足这些特性。

#### 1.原子性：

* java中几乎可以认定为基本数据类型的访问读写是具备原子性的，如果用户还需要一个更大范围的原子性保证，那么可以采用synchronized关键字。

#### 2.可见性：

* volatile
* synchronized
* final

#### 3.有序性：

* volatile（通过内存屏障达到有序性的目的）
* synchronized（通过互斥同步，保证一个变量同一时间只有一个线程能够对其进行lock操作达到有序性目的）