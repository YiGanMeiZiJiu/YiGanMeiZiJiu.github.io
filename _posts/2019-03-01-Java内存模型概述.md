---
layout: post
title:  "Java内存模型概述!"
date:   2019-03-01 20:30:59 +0100
---
Java内存模型是Java JVM规范中定义的一套规则，试图以此来屏蔽硬件系统与操作系统间内存的访问差异，达到一个全平台通用的一个效果。例如C/C++直接使用物理硬件系统的内存模型，就有可能同一套代码，在这里的平台上并发运行通畅，换一处就问题连连，问题即是出在这里。   

---
Java内存模型的主要任务就是定义程序中各变量的访问规则。这里的变量指的是需要程序共享的实例字段，静态字段，数组等需要各程序共享的变量，例如局部变量，方法参数等不包括在内，因为那些是线程私有的，不需要共享。这里的java内存模型我们主要分为主内存与工作内存两块。  

---
```
1.主内存  
Java内存模型规定了所有共享变量都需要存储在主内存之中（此处的主内存指的是虚拟机的一部分）
```

```
2.工作内存  
每条线程都拥有自己的工作内存,用来保存用到的主内存中的共享变量的副本，线程对变量的所有操作（读取，赋值等）都无法直接读写主内存中的变量，必须通过工作内存，不同线程也无法读取到各自对应的工作内存中的数据。多线程并发问题也就由此而生，接下去的博客会讲到如何处理多线程的问题。本篇不多介绍。
```

```
3.主内存与工作内存对应关系图解
```
![Java内存模型]({{ site.url }}/assets/Java内存模型.png)

> 本篇中讲到的主内存，工作内存等概念与Java虚拟机内存模型中提到的堆内存，栈内存等并没有关联，他们是两套独立开来的系统，如果说硬要有一些对应关系的话，那么主内存就相当于Java堆中的对象实例数据部分，工作内存的话就相当于虚拟机栈中的部分区域。  

- [ ] Java内存模型中定义了8种操作来完成内存间的交互操作（即一个变量由主内存中拷贝至工作内存，由工作内存同步回主内存等）
- lock（锁定）：用于将主内存中的一个变量标示成某个线程独占的标志
- unlock（解锁）：用于将主内存中一个锁定的变量变成解锁状态，此时该变量可以被其他线程锁定
- read（读取）：用于将主内存的值读取至工作内存中，方便后来的load操作
- load（载入）：用于将工作内存读取到的变量值放入变量副本中
- use（使用）：用于将工作内存中的变量值传给执行引擎
- assign（赋值）：用于将执行引擎接收到的值赋给工作内存中的变量副本
- store（存储）：用于将工作内存中的一个变量传输给主内存，方便后面的write（写入）操作
- write（写入）：用于将store操作，从工作内存中得到的变量值写入主内存的变量中  

- [x] 如果要把一个变量从主内存中拷贝至工作内存中，那就顺序的执行

```
read-->load
```
- [x] 如果要将一个变量从工作内存中同步回主内存中，那就顺序的执行

```
store-->write
```

---
换句话说，Java内存模型是针对"有序性，可见性"，规范了JVM提供的按需禁用缓存（针对可见性）和编译优化（针对有序性）的方法！其中主要内容就是包括volatile，synchronized，final三个关键字和六条happens-before原则。   
1.volatile   
volatile的语义中就带着可见性，即多个线程从主内存中读取共享变量的值到工作内存中，那么不管哪个线程对其值的操作都是对于其他线程来说都是可见的。而有序性的保障则是通过在volatile修饰的变量操作中插入内存屏障，cpu无法将语句重排序插入到内存屏障之前或之后，以此来达到有序性的保障。
2.synchronized
synchronized同步块保证可见性原则的则是，synchronized关键字达到同步的方法其实是默认上锁达到的，而对一个变量进行unlock时，必须把此变量同步回主内存中。而有序性则是因为synchronized关键字通过上锁保证同一时刻只有一条线程能对该共享变量进行lock操作达到的。
3.final
被final修饰的字段，在构造器中一旦初始化完成，而且构造器没有将this的引用传递出去，那么该字段就是无法修改的，其他线程只能读到final字段的值，自然不存在可见性问题。
4.六条happens-before原则（前面一个操作的结果对后面的操作是可见的）
- 在单一线程中，根据代码的顺序，程序前面对一个变量的修改对后面的操作一定是可见的。
- 被volatile修饰的变量的写操作，先行发生于后续对该变量的读操作。
- 若A操作先行发生于B，B先行发生于C，那么A久先行发生于C。
- 对一个变量的解锁先行发生于后续对这个变量的加锁。
- 主线程A启动了线程B，那么B能看到A在启动B之前的操作。
- 主线程A等待子线程B完成，当B完成后，A能看到B的操作。