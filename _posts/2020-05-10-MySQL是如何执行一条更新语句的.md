---
layout: post
title:  "MySQL是如何执行一条更新SQL的"
date:   2020-05-10 20:43:57 +0100
---

一条MySQL的更新语句的流程是怎样的呢？     
举个例子：      
create table T(id int primary key, c int);      
然后执行一条更新语句：     
update T set c = c+1 where id = 2;       
我们来分析一下它的执行流程是什么？   
- 执行语句之前，需要连接数据库，这是连接器的工作     
- 接下来，分析器会通过词法和语法分析知道这是一条更新语句。     
- 优化器决定使用id这个索引    
- 执行器负责具体执行，找到这一行，并执行更新     
与查询流程不一样的是，更新流程还涉及到两个重要的日志模块，redo log 和 binlog。

1. **redo log：**
在MySQL中，如果每一次的更新都需要立刻实时的写进磁盘，那么磁盘每次都要找到对应的需要更新的记录，然后再更新，整个过程的IO，查找成本，都会让人接受不了。为了解决这个问题，    
MYSQL采用了WAL技术      
**WAL（Write-Ahead Loggin）**
**简而言之，关键点就是：先写日志，再写磁盘。**      
具体来说，当有一条更新语句过来时，InnoDB引擎会先把记录写到redo log中，并且更新内存中的值，这时候，其实这条更新语句就算是完成了。同时，InnoDB会选择在系统比较空闲的时候，将操作记录更新到磁盘中。     
![RedoLog]({{ site.url }}/assets/redo.png)     
write pos是当前redo log记录的位置，一边写一边后移，当一个圆环写满，会回到起点，对应着粉板被写满。checkpoint是当前要擦除的位置，也是向后推移且循环的，擦除之前需要把更新操作更新到磁盘上。write pos和check ponit之间代表着粉板上空着的位置，也就是redo log可以用来记录新操作的位置，当write pos追上check point时，代表redo log已经被写满了，此时不能再执行新的更新操作，必须停下来，擦除一部分redo log，将check point的位置向前推移一点，才能继续更新。
而redo log的存在，也变相的保证了mysql的carsh-safe能力。也就是数据库发生异常重启，之前提交执行的更新记录不会丢失。这里先举个例子说明一下原理，后续实现等下再说，就是例如店老板只要把赊账记录记在了粉板上或写在了账本上，之后即使老板忘记了，突然店停业了几天，恢复生意后依然可以通过账本和粉板上的数据对出一个正确的账目。     

**刷脏**     
刷脏，简而言之，就是当内存页中的数据与磁盘中的数据不一致之后，需要将内存页中的数据刷新到磁盘中去       
有几种情况会产生刷脏的可能性：      
- redo log写满了之后，此时，新的更新操作已经无法再次写入，因为update是将数据写入redo log之后更新内存页中的数据，但是redo log满了，导致此时mysql必须停下手头上的事情，去将redo log的一部分先更新到磁盘中，所以有可能有一条更新语句会卡，有可能就是刷脏导致的。
- 系统内存不足了，需要将一些脏页淘汰，，此时也会将脏页刷到磁盘上
- 系统空闲时，MySQL定期将脏页刷到磁盘,可以想象，场景1和场景2都会有可能导致一条正常的select语句变成慢查询。    
- InnoDB的刷脏策略：全量刷脏（关闭数据库时），部分刷脏（运行时）。部分刷脏又分为定期刷脏，最近最少使用刷脏，异步/同步刷脏，脏页过多刷脏等。

2. **bin log：**   
MySQL整体看来，其实就分两块，一块Server层，一块引擎层。而redo log是针对InnoDB引擎层作用的日志，binlog则适用于归档，针对于Server层。
上面已经说了redo log的存在，是用来记录某一个页做了什么改动的物理日志，那么binlog是干嘛的呢？binlog就是记录语句原始逻辑的逻辑日志。详细一点就是给id=2的行数据的a字段加1；binlog有两种模式，statement模式是记录本次更新语句的sql，row模式记录的是更新前更新后的两行数据。     
redo log是循环写的，空间固定会用完，就需要擦除才能重新写，binlog是追加写的，，当大小写到一定大小后悔切换下一个写，不会覆盖之前的binlog。   
有了对这两个日志概念性的理解，我们再来看执行器和InnoDB在执行这个简单的语句时候的内部流程：     
- 执行器先找引擎获取id=2这一行数据，id是主键，引擎直接用树搜索找到这一行。如果id=2这一行所在的数据页本来就在内存中，就直接返回给执行器，否则，就去磁盘中将数据读入内存，然后再返回。
- 执行器拿到这一行数据之后，把a的值加上1，得到一行新的数据，再调用引擎写入这行新数据。
- 引擎将这行数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log处于prepare状态，然后告诉执行器，写入完毕了，随时可以提交事务。
- 执行器写入这个操作的binlog，并将binlog持久化到磁盘。
- 执行器调用引擎的事务提交接口，引擎把刚刚写好的redo log改成commit状态。本次更新完成。  
你们可能注意到了针对于redo log的提交有点绕，由prepare转到commit，分成了两个步骤提交。这就是MySQL的两阶段提交。    
**两阶段提交**
为什么需要两阶段提交？记得我们前面抛出来的一个问题么？数据库的记录是可以恢复的，那么如何将数据库恢复到半个月内的任何一个时间的状态？前面我们说了，binlog会用追加写的方式记录所有的逻辑操作，那么只要取出近半个月内的binlog，同时系统会定期做全库备份，（可以是一天，也可以是一个礼拜。）那么，恢复数据就比较简单了，找到最近一次的全量备份，然后，从备份的时间点开始，将备份的binlog依次取出，重新放回备份的库中。然后你的备份库中的数据就恢复完毕了。      
讲完了如何数据恢复，我们会来说说为什么日志需要两阶段提交？答案就是为了保证数据的一致性。我们不妨举个例子看看。    
如果说不采用两阶段提交，update T set c=c+1 where id = 2; 那么要么先写binlog，要么先写redo log，，如果先写binlog，还没写redo log，此时宕机了，那么此时由于redo log没有写入，磁盘中原库的值就不会有crash-safe，所以c还是为1，而binlog中却写入了+1的操作，那么就造成了日志中的操作结果与库对应不上，相反，redo log写入了，而bin log中没有写入，此时宕机，crash-safe会将原库中的数据还原成2，但是binlog却没有记录下本次逻辑操作，如果需要数据恢复的话，那么binlog就没有办法恢复本条更新。    
而采用两阶段提交之后，redo log（prepare）1  ->  写binlog  -> 2 redo log（commit）
如果在位置1挂掉，即redo log处于prepare状态，binlog尚未写入，程序宕机，crash-safe时，会发现binlog中没有本次更新，且redo log处于prepare，那么本次事务会被认定为无效，发生回滚，前后数据保持一致。         
如果在位置2挂掉，redo log处于prepare状态，binlog成功写入，此时崩溃恢复过程会认定事务有效，并提交事务，保持了数据的一致性。     
简单来说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是为了让这两个状态保持逻辑上的一致。     