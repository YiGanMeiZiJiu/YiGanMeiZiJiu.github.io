---
layout: post
title:  "MVCC多版本并发控制"
date:   2020-10-21 20:43:57 +0100
---
🍊 我们知道，MySQL的事务隔离级别有，可重复读，读提交，读未提交，串行化等。不同的隔离级别对MySQL数据本身的保护程度不一样，性能也不一样。今天我来记录一下可重复读级别下的MVCC是如何工作的。

在 MySQL 里，有两个“视图”的概念：
- 一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。
- 另一个是 InnoDB 在实现 MVCC （多版本并发控制）时用到的一致性读视图，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。(它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。)       

我们知道可重复读级别下，在事务启动时，会开启一个视图，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。这样对我们备份数据还是一些其他的场景下有非常巨大的帮助。

1. **视图在MVCC里是怎么实现的？**
- InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。
- 而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。其实就是，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。
- 一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。
- 在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。
- 这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：      
  如果当前事务ID小于低水位，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；     
  如果当前事务ID大于高水位，表示这个版本是由将来启动的事务生成的，是肯定不可见的；     
  如果当前事务ID小于高水位，大于低水位，那就包括两种情况。
    若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；      
    若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。     

所以这就是InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。也就是MVCC。

3. **事务的可重复读能力是怎么实现的？**
- 可重复读的核心就是一致性读；而事务更新数据的时候，只能用当前读(更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”)。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。
- 而读提交的逻辑和可重复读的逻辑类似，它们最主要的区别是：
  在可重复读隔离级别下，只需要在事务开始的时候创建一致性视图，之后事务里的其他查询都共用这个一致性视图；     
  在读提交隔离级别下，每一个语句执行前都会重新算出一个新的视图。      
- InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。
- 对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
- 对于读提交，查询只承认在语句启动前就已经提交完成的数据；
- 当前读，总是读取已经提交完成的最新版本。

