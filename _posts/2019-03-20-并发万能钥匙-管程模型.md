---
layout: post
title:  "并发万能钥匙-管程"
date:   2019-03-20 20:47:23 +0100
---
Java语言在1.5以前，提供的唯一并发原语就是**管程**技术，它的组成部分也就是synchronized关键字和wait(),notify(),notifyAll()这三个方法。而在1.5之后，Java提供的SDK并发包，也是以管程技术为基础的。**可以这么说，管程就是解决并发问题的一把万能钥匙.**

**什么是管程**    

所谓管程，字面翻译指的是**管理共享变量，和对共享变量的操作过程**,翻译为Java领域的语言就是管理类的成员变量，成员方法，让这个类是线程安全的。在管程的发展史上，曾经出现过三种不同的管程模型，他们分别是应用最多的**MESA模型**，还有Hasen模型和Hoare模型。众所周知，在并发领域两个最大的问题就是**互斥**和**同步**。那么管程模型是如何进行互斥和同步的呢？   

1. MESA模型解决互斥问题     

MESA模型解决互斥的方法就是，将共享变量以及对共享变量的操作统一封装起来，在同一时刻，只允许一个线程进入管程，保证互斥性。
>举个例子，如下图，管程X将共享变量queue队列和相关的出队deq(),入队enq()操作都封装起来了，线程A和线程B想访问queue，只能通过访问管程X提供的deq和enq，而他们保证互斥性，只允许一个线程进入.在前面讲过的互斥锁，背后的模型就是管程    

![管程模型互斥]({{ site.url }}/assets/管程互斥.png)

2. MESA线程解决同步问题      

MESA模型解决同步问题的方法就是条件变量，而且**每个条件变量都有一个对应的等待队列**。在管程模型中，共享变量和对共享变量的操作是被封装起来了的，管程的入口只有一个，并且同一时刻只允许一个线程进入，所以在入口处会有一个等待队列。可以结合一下下图的例子理解一下条件变量和等待队列的作用。
>有一个队列的共享变量，有一个条件变量，队列不满（notFull），另一个条件变量，队列不空（notEmpty）
- 对于入队操作，如果队列已满，那么线程就要进入队列不满的等待队列中，notFull.wait();等待唤醒执行
- 对于出队操作，如果队列为空，那么线程就要进入队列不空的等待队列中，notEmpty.wait();等待唤醒执行
- 如果入队成功，那么就要唤醒一个队列不空等待队列中的等待线程，重新进入入口处的等待队列，等待执行,notEmpty.notify();
- 如果出队成功，那么就要唤醒一个队列不满等待队列中的等待线程，重新进入入口处的等待队列，等待执行，notFull.notify();
![管程模型同步]({{ site.url }}/assets/管程同步.png)

**三大管程模型对比**
>Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是什么时候通知相关线程执行，加入T1的执行使得T2的条件变量被满足，那么T1何时通知T2开始执行呢？
1. Hasen模型中，要求notify()关键字放在最后。也就是T1线程执行中，满足了线程T2的执行条件变量，那么T1会在自身执行完毕的最后，调用notify去唤醒T2继续执行。这样T1执行完了T2在执行，就能保证同一时刻只有一个线程在执行。
2. Hoare模型中，T1在执行时满足了T2的条件变量，此时T1自己会阻塞，然后通知T2执行，等待T2执行完毕后，T1再被唤醒继续执行。这样也可以保证同一时间只有一个线程执行，但是相比Hasen模型，会增加一次阻塞唤醒的资源浪费。
3. MESA模型是，T1执行导致T2的条件变量被满足，那么T1会通知T2，但是T1此刻仍然继续执行，而T2并不会马上执行，T2只会从条件变量的等待队列中重新进入到管程入口处的等待队列中重新竞争进入管程的机会。这样的话不用强迫notify的位置，也不用多耗费阻塞唤醒的资源。但是也有一个副作用，就是T1执行的时候唤醒T2，此时T2的条件变量是满足的，但是，等到T2真正再次进入管程时，就不敢保证了，所以需要while循环方式重复验证条件变量。

**附**    

notify的使用规则
当我们使用notify时必须满足以下三条条件   
- 所有等待线程拥有相同的等待条件
- 所有等待线程被唤醒后，执行的都是同样的操作
- 只需要唤醒一个等待线程